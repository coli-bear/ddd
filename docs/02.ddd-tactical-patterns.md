# 2단계: DDD 전술적 패턴 (Tactical Patterns)

> 참고 : Chat GPT5<br/>
> [소스코드](../ddd-tactical-patterns)

전술적 패턴이란 바운디드 컨텍스트 내부에서 도메인 모델을 코드로 구현할 때 쓰는 도구 상자다.

## 전술적 패턴의 구성요소

전술적 패턴의 주요 구성 요소는 다음과 같다.

- 엔티티 (Entity), VO (Value Object), 애그리거트 (Aggregate) : 도메인 모델의 뼈대가 된다.
- 리포지토리 (Repository) : 애그리거트의 영속성 경계를 추상화 한다. 이는 데이터베이스에 접근을 캡슐화 한다. (예: JPA Repository)
- 팩토리 (Factory) : 복잡한 생성 규칙을 캡슐화 한다.
- 도메인 서비스 (Domain Service) : 도메인 로직을 캡슐화 한다. 엔티티나 VO에 속하지 않는 로직을 구현한다.
- 애플리케이션 서비스 (Application Service) : 유스케이스를 구현한다. 도메인 모델과 리포지토리를 조합하여 비즈니스 로직을 수행한다.
- 도메인 이벤트 (Domain Event) : 도메인 내에서 발생하는 변화를 모델 밖으로 명시적으로 발행(Publish) 한다.

앞서 기본적인 Entity, VO, 애그리게이트에 대해서 설명을 했으므로 여기서는 리포지토리, 팩토리, 도메인서비스, 애플리케이션 서비스, 도메인 이벤트에 대해서 설명한다.

## 전술적 패턴을 이용한 Java 코드

### 1. 리포지토리 (Repository)

리포지토리는 애그리거트의 영속성을 추상화하는 역할을 한다. 도메인 모델이 데이터베이스와 직접적인 상호작용을 하지 않도록 하며, 애그리거트 루트를 통해서만 접근할 수 있도록 한다.

#### 리포지토리의 역할과 구현

리포지토리는 기본적으로 CRUD 작업을 수행하며, 애그리거트 루트를 기준으로 데이터를 조회하고 저장하는 메서드를 제공한다.

```java
interface OrderRepository {
    void save(Order order);

    Optional<Order> findById(UUID id);

    List<Order> findByCustomerId(UUID customerId);
}
```

이때 리포지토리가 데이터베이스에 접근하기 위해서는 JPA, MyBatis 등 다양한 기술을 사용할 수 있다 Spring Boot 환경에서는 Spring Data JPA를 사용하여 리포지토리를 쉽게 구현할 수 있다.

#### JPA 를 이용한 리포지토리 구현 예시

```java
interface JpaOrderRepository extends JpaRepository<Order, UUID>, OrderRepository {
    List<Order> findByCustomerId(UUID customerId);
}
```

JPA Repository 는 샘플로 구현하지 않음

#### In memory 구현 예시

```java
class InMemoryOrderRepository implements OrderRepository {
    private final Map<UUID, Order> store = new HashMap<>();

    @Override
    public void save(Order order) {
        if (order.getId() == null) {
            order.setId(UUID.randomUUID());
        }
        store.put(order.getId(), order);
    }

    @Override
    public Optional<Order> findById(UUID id) {
        return Optional.ofNullable(store.getOrDefault(id, null));
    }

    @Override
    public List<Order> findByCustomerId(UUID customerId) {
        return store.values().stream()
            .filter(order -> order.getCustomerId().equals(customerId))
            .collect(Collectors.toList());
    }
}
```

In memory 구현은 테스트용도로 사용할 수 있으며, JPA 영속성 컨텍스트에서 생성되는 Id 값은 직접 관리해야 한다. 이때 리플렉션을 이용하여 setter 를 사용하지 않고 구현할 수 있다.

### 2. 팩토리 (Factory)

팩토리는 애그리거트의 생성 과정을 캡슐화 하는 역할을 한다. 또한 생성 과정이 복잡하거나 **불변성**을 만족해야 할 때 생성 로직을 한 곳에 모아 관리할 수 있다.

```java
public class OrderFactory {
    public Order createNewOrder(UUID customerId, List<OrderItem> items) {
        if (items == null || items.isEmpty()) {
            throw new IllegalArgumentException("Order must have at least one item");
        }

        Order order = new Order(customerId);
        items.forEach(order::addItem);
        return order;
    }
}
```

이러한 팩토리는 다수의 정책 검사가 필요하거나, 많은 파라미터와 복잡한 조합, 서브클래스 및 전략적 선택이 필요한 생성에서 사용한다.

- 생성시 다수의 정책 검사 필요한 경우
- 생성 파라미터가 많고 조합이 복잡한 경우
- 서브클래스/전략 선택이 필요한 경우

### 3. 도메인 서비스 (Domain Service)

일반적으로 도메인 모델의 상태를 변경하거나 처리하는 행동은 애그리거트에서 동작하지만 특정 엔티티에 종속되지 않는 도메인 규칙을 생성해야 할 때가 있다. 이때 도메인 서비스를 사용한다.

예를 들어 할인 정책 계산이나 재고 검증 등 여러 애그리거트를 조합해야하는 경우이다.

```java
class PricingService {
    public Money calculateOrderTotal(List<OrderItem> items, DiscountPolicy discountPolicy) {
        Money total = items.stream()
            .map(OrderItem::geinlineTotal)
            .reduce(Money.ZERO, Money::add);
        return discountPolicy.apply(total);
    }
}
```

이때 도메인 서비스는 STATELSS 해야 한다. 즉, 도메인 서비스는 상태를 가지지 않고, 입력값에 따라 결과가 결정되는 순수 함수형이어야 한다.

#### Domain Service vs Application Service vs Business Service

| 구분 | Domain Service                | Application Service    | Business Service           |
|----|-------------------------------|------------------------|----------------------------|
| 역할 | 엔티티 또는 VO에 넣기 애매한 도메인 규칙을 캡슐화 | 유스케이스 구현 또는 트랜잭션/흐름 관리 | 비즈니스 로직을 수행하는 서비스를 총괄해서 지칭 |
| 위치 | 도메인 계층                        | 애플리케이션 계층              | 도메인 또는 애플리케이션 계층           |
| 상태 | 상태 없음 (Stateless)             | 상태 없음 (Stateless)      | 상황에 따라 상태를 갖을 수 있음         |
| 예시 | 할인 정책 계산, 재고 검증 등             | 주문 생성, 사용자 등록 등        | 도메인, 애플리케이션 둘 다 가능         |

### 5. 도메인 이벤트 (Domain Event)

도메인 이벤트는 도메인 내에서 발생하는 중요한 변화를 나타내는 객체이다. 도메인 이벤트를 사용하면 시스템의 상태 변화나 중요한 사건을 명시적으로 표현할 수 있다. 이는 이벤트 소싱(Event Sourcing)이나 CQRS(Command Query Responsibility Segregation)와 같은 아키텍처 패턴과도 잘 어울린다.

도메인 이벤트는 먼저 이벤트를 정의해야 한다. 

```java
public interface DomainEvent {
    Instant occurredAt();
}

public record OrderPlacedEvent(UUID orderId, UUID customerId, Instant occurredAt) implements DomainEvent {
    public OrderPlacedEvent {
        if (occurredAt == null) {
            occurredAt = Instant.now();
        }
    }
}

public record OrderCancelledEvent(UUID orderId, UUID customerId, Instant occurredAt) implements DomainEvent {
    public OrderCancelledEvent {
        if (occurredAt == null) {
            occurredAt = Instant.now();
        }
    }
}
```

이러한 이벤트는 애그리거트에서 생성하고 보관하게 된다. 

```java
class Order {
    private final List<DomainEvent> events = new ArrayList<>();

    // ...

    public void place() {
        if (orderItems.isEmpty()) {
            throw new IllegalStateException("Order must have at least one item");
        }
        this.status = OrderStatus.PLACED;
        // 주문 생성 이벤트 등록 
        domainEvents.add(new OrderPlacedEvent(this.id, this.customerId, Instant.now()));
    }

    public void cancel() {
        if (this.status == OrderStatus.CANCELLED) {
            throw new IllegalStateException("Order is already cancelled");
        }
        this.status = OrderStatus.CANCELLED;
        // 주문 취소 이벤트 등록
        domainEvents.add(new OrderCancelledEvent(this.id, this.customerId, Instant.now()));
    }
    
    public List<DomainEvent> pullDomainEvents() {
        List<DomainEvent> copyEvents = List.copyOf(events);
        events.clear();
        return copyEvents;
    }

}
```

도메인 이벤트를 발행하는 방법은 여러가지가 있지만, 가장 간단한 방법은 애그리거트에서 이벤트를 수집하고, 애플리케이션 서비스에서 이를 발행하는 것이다.

이렇게 발행된 이벤트는 이벤트 핸들러에 의해 처리될 수 있다.

```java
public interface EventPublisher {

    void publish(DomainEvent event);

    void register(Class<? extends DomainEvent> type, EventHandler<? extends DomainEvent> handler);

    interface EventHandler<T extends DomainEvent> {
        boolean handle(T event);
    }
}

public class SimpleEventPublisher implements EventPublisher {
    private final Map<Class<? extends DomainEvent>, List<EventHandler<? extends DomainEvent>>> handlers = new HashMap<>();

    @Override
    public void publish(DomainEvent event) {
        handlers.getOrDefault(event.getClass(), List.of()).stream()
            .map(h -> (EventHandler<DomainEvent>) h) // unchecked cast
            .forEach(h -> h.handle(event));
    }

    @Override
    public void register(Class<? extends DomainEvent> type, EventHandler<?> handler) {
        handlers.computeIfAbsent(type, k -> new ArrayList<>()).add(handler);
    }
}

public class OrderCancelledEventHandler implements EventHandler<OrderCancelledEvent> {

    private final List<OrderCancelledEvent> events = new ArrayList<>();

    @Override
    public void handle(OrderCancelledEvent event) {
        if (event == null) {
            throw new IllegalArgumentException("Event cannot be null");
        }

        events.add(event);
    }
}
```

### 6. 애플리케이션 서비스 (Application Service)

애플리케이션 서비스는 도메인 모델을 사용해서 유스케이스르 구현하는 역할을 한다. 이때 트랜잭션, 보안, 워크플로우를 담당하게 된다. 이러한 애플리케이션 레이어는 아래와 같은 특징들을 갖는다. 

- 도메인 규칙 자체를 담지 않는다. 
- 리포지토리의 호출, 도메인 서비스 호출, 애그리거트 조작등 워크플로우를 담당한다.
- 주로 사용자/외부 요청 -> 애플리케이션 서비스 -> 도메인 모델 순서로 흐름이 들어온다.

```java
public class PriceOrderService {
    private final OrderRepository orderRepository;
    private final OrderFactory orderFactory;
    private final EventPublisher eventPublisher;
    public PriceOrderService(OrderRepository orderRepository, OrderFactory orderFactory, EventPublisher eventPublisher) {
        this.orderRepository = orderRepository;
        this.orderFactory = orderFactory;
        this.eventPublisher = eventPublisher;
    }

    // Transactional 어노테이션을 이용해서 JPA 영속성 컨텍스트를 유지한다. (여기서는 의존성 주입을 하지 않아서 주석 처리)
    // @Transactional
    public UUID price(UUID customerId, List<OrderItem> orderItems) {
        Order newOrder = orderFactory.createNewOrder(customerId, orderItems);
        newOrder.place();
        orderRepository.save(newOrder);
        newOrder.pullDomainEvents().forEach(eventPublisher::publish);
        return newOrder.getId();
    }
}
```

## GPT의 TDD 팁 - 전술패턴과 TDD 의 궁합 

1. 테스트 진행시 애그리거트 단위로 규칙을 테스트 한다.
   - Given(상태) - When(행위) - Then(결과 또는 이벤트)
2. 리포지토리는 인메모리 대역으로 빠르게 테스트 가능하다.
    - JPA 영속성 컨텍스트를 이용한 테스트는 느리다.
3. 도메인 서비스는 순수 함수에 가깝게 설계한다.
   - 격리 테스트가 쉽다. 
4. 애플리케이션 서비스 테스트는 흐름/트랜잭션/이벤트 발행 여부를 검증한다. 
   - 목(mock) 객체를 이용하여 리포지토리, 도메인 서비스, 이벤트 퍼블리셔의 호출 여부를 검증한다.