# 4단계; 유비쿼터스 언어(Ubiquitous Language)

## 1. 정의와 목적

### 1.1 유비쿼터스 언어란?
유비쿼터스 언어(Ubiquitous Language)는 도메인 주도 설계(DDD)의 핵심 개념 중 하나로, 특정 바운디드 컨텍스트 내에서 도메인 전문가와 개발팀이 공통으로 사용하는 엄격하게 정의된 언어입니다.

### 1.2 핵심 특징
- **일관성**: 코드, 문서, 대화, 모델링 산출물 등 모든 곳에서 동일한 용어 사용
- **정확성**: 도메인 전문가가 사용하는 실제 비즈니스 용어를 그대로 반영
- **명확성**: 모호하지 않고 구체적인 의미를 가진 용어 사용
- **진화성**: 도메인 이해가 깊어질수록 언어도 함께 발전

### 1.3 목적
- **의사소통 불일치 제거**: 도메인 전문가와 개발자 간의 번역 오류 방지
- **도메인 지식의 일관성 유지**: 비즈니스 로직의 정확한 구현
- **코드 가독성 향상**: 비즈니스 의도가 명확히 드러나는 코드 작성
- **유지보수성 개선**: 새로운 팀원도 쉽게 이해할 수 있는 코드베이스 구축

## 2. 도메인 모델과 코드에의 반영

### 2.1 클래스와 메서드명에의 반영

#### 전자상거래 예시
```java
// 좋은 예: 유비쿼터스 언어 반영
public class Order {
    public void cancel() { ... }           // "주문을 취소한다"
    public void ship() { ... }             // "주문을 발송한다"
    public void refund() { ... }           // "주문을 환불한다"
}

// 나쁜 예: 기술적 용어 사용
public class OrderData {
    public void delete() { ... }           // 삭제? 취소?
    public void send() { ... }             // 전송? 발송?
    public void return() { ... }           // 반환? 환불?
}
```

#### 은행 도메인 예시
```java
// 좋은 예
public class Account {
    public void deposit(Money amount) { ... }      // "입금하다"
    public void withdraw(Money amount) { ... }     // "출금하다"
    public void transfer(Money amount, Account to) { ... } // "이체하다"
}

// 나쁜 예
public class BankAccount {
    public void add(BigDecimal value) { ... }      // 추가? 입금?
    public void subtract(BigDecimal value) { ... } // 빼기? 출금?
    public void move(BigDecimal value, BankAccount target) { ... } // 이동? 이체?
}
```

### 2.2 도메인 개념의 명시적 모델링

#### 상태와 행위의 명확한 표현
```java
// 주문 상태를 유비쿼터스 언어로 표현
public enum OrderStatus {
    PLACED("주문접수"),
    PAYMENT_CONFIRMED("결제확인"),
    PREPARING("준비중"),
    SHIPPED("발송완료"),
    DELIVERED("배송완료"),
    CANCELLED("취소됨");
}

// 비즈니스 규칙을 메서드명으로 표현
public class Order {
    public boolean canBeCancelled() {
        return status == PLACED || status == PAYMENT_CONFIRMED;
    }
    
    public boolean isEligibleForRefund() {
        return status == DELIVERED && 
               deliveredDate.isAfter(LocalDate.now().minusDays(7));
    }
}
```

## 3. 협업에서의 역할

### 3.1 도메인 전문가와의 소통
유비쿼터스 언어는 도메인 전문가와 개발자 사이의 '번역자' 역할을 제거합니다.

#### 기존 방식 (번역 필요)
```
도메인 전문가: "고객이 상품을 반품하려고 할 때..."
↓ (번역)
개발자: "User가 Product를 return하려고 할 때..."
```

#### 유비쿼터스 언어 적용
```
공통 언어: "고객이 상품을 반품하려고 할 때..."
코드: customer.returnProduct(product)
```

### 3.2 팀 내부 소통 개선
- **코드 리뷰**: "이 메서드는 비즈니스적으로 '환불 처리'를 의미하나요?"
- **버그 리포트**: "'주문 취소' 기능에서 문제가 발생했습니다"
- **기능 논의**: "'할인 적용' 로직을 수정해야 합니다"

## 4. 잘못된 언어 사용의 문제점과 해결책

### 4.1 용어 불일치로 인한 문제점

#### 문제 사례 1: 동일 개념, 다른 용어
```java
// 도메인 전문가: "주문을 취소한다"
// 개발자 A: cancelOrder()
// 개발자 B: deleteOrder()
// 개발자 C: removeOrder()
```
**결과**: 같은 기능을 구현하는데 서로 다른 메서드를 찾아헤맴

#### 문제 사례 2: 다른 개념, 같은 용어
```java
// "삭제"라는 용어로 서로 다른 개념 표현
public void deleteOrder() { ... }      // 주문 취소
public void deleteCustomer() { ... }   // 고객 정보 완전 삭제
```

### 4.2 해결책

#### 용어집(Glossary) 작성 및 관리
##### 주문 도메인 용어집

| 용어 | 영문 | 정의 | 코드 표현 |
|------|------|------|-----------|
| 주문 접수 | Place Order | 고객이 상품을 주문하는 행위 | order.place() |
| 주문 취소 | Cancel Order | 접수된 주문을 무효화하는 행위 | order.cancel() |
| 주문 변경 | Modify Order | 발송 전 주문 내용을 수정하는 행위 | order.modify() |
| 환불 | Refund | 결제된 금액을 고객에게 돌려주는 행위 | payment.refund() |
| 반품 | Return | 배송된 상품을 다시 돌려받는 행위 | order.returnProduct() |

## 5. 실제 프로젝트 적용 방법 및 팁

### 5.1 언어 발견 과정

#### 단계 1: 도메인 전문가와의 인터뷰
```
질문 예시:
- "이 상황을 어떻게 부르시나요?"
- "이것과 저것의 차이점은 무엇인가요?"
- "언제 이 작업을 수행하시나요?"
- "이 작업의 전제 조건은 무엇인가요?"
```

#### 단계 2: 이벤트 스토밍을 통한 언어 추출
```
이벤트: 주문이 접수되었다
명령: 주문을 접수한다
집계: 주문 (Order)
정책: 재고가 충분할 때만 주문을 접수한다
```

#### 단계 3: 용어의 정제 및 정의
```java
// 초기 버전
public void processOrder() { ... }

// 정제 후
public void placeOrder() { ... }  // "주문을 접수한다"는 의미로 명확화
```

### 5.2 언어 진화 관리

#### 버전 관리를 통한 언어 변화 추적
```markdown
## 용어 변경 이력

### v1.0 (2024-01-01)
- 주문 상태: 접수됨, 처리중, 완료됨

### v1.1 (2024-02-15)
- 주문 상태 세분화: 접수됨, 결제확인됨, 준비중, 발송됨, 배송완료됨
- 사유: 물류팀의 요청으로 배송 상태 추적 필요

### v1.2 (2024-03-10)
- "취소됨" 상태 추가
- "준비중"을 "포장중"으로 명칭 변경
- 사유: 창고 운영팀의 실제 업무 프로세스에 맞춤
```

### 5.3 코드 품질 유지 방법

#### 정적 분석을 통한 용어 일관성 검사
```java
// 금지된 용어 사용 시 경고
@Deprecated(reason = "Use cancel() instead. 'delete' doesn't reflect business meaning")
public void deleteOrder() { ... }

// 올바른 용어 사용 권장
public void cancelOrder() { ... }
```

#### 테스트 코드에서의 언어 사용
```java
@Test
public void 고객이_주문을_취소할_수_있다() {
    // Given: 주문이 접수된 상태
    Order order = Order.place(customerId, products);
    
    // When: 고객이 주문을 취소한다
    order.cancel();
    
    // Then: 주문 상태가 취소됨으로 변경된다
    assertThat(order.getStatus()).isEqualTo(OrderStatus.CANCELLED);
}
```

### 5.4 팀 문화 구축

#### 일일 스탠드업에서의 언어 사용
```
❌ "User 테이블의 delete 메서드를 수정했습니다"
✅ "고객 탈퇴 기능을 개선했습니다"

❌ "Payment 프로세싱 로직에 버그가 있습니다"
✅ "결제 처리 과정에서 문제가 발견되었습니다"
```

#### 코드 리뷰 체크리스트
- [ ] 메서드명이 비즈니스 의도를 명확히 표현하는가?
- [ ] 클래스명이 도메인 개념을 정확히 반영하는가?
- [ ] 변수명이 용어집의 정의와 일치하는가?
- [ ] 주석이 필요한 복잡한 비즈니스 로직이 메서드명으로 표현되었는가?

## 6. 도구와 기법

### 6.1 용어집 관리 도구
- **Confluence/Notion**: 팀 공유 용어집 작성
- **PlantUML**: 도메인 모델 다이어그램에 용어 반영
- **아키텍처 결정 기록(ADR)**: 용어 변경 사유와 영향도 기록

### 6.2 코드에서의 언어 표현 기법

#### 값 객체를 통한 도메인 개념 표현
```java
// 단순한 문자열 대신 도메인 개념으로 표현
public class CustomerName {
    private final String value;
    
    public CustomerName(String value) {
        if (value == null || value.trim().isEmpty()) {
            throw new IllegalArgumentException("고객명은 필수입니다");
        }
        this.value = value;
    }
}

// 사용
Customer customer = new Customer(
    new CustomerName("홍길동"),
    new EmailAddress("hong@example.com")
);
```

#### 도메인 서비스를 통한 비즈니스 규칙 표현
```java
@Service
public class OrderCancellationService {
    
    public void cancelOrder(Order order, CancellationReason reason) {
        if (!order.canBeCancelled()) {
            throw new OrderCannotBeCancelledException(
                "주문 상태가 '" + order.getStatus() + "'일 때는 취소할 수 없습니다"
            );
        }
        
        order.cancel(reason);
        eventPublisher.publish(new OrderCancelledEvent(order.getId(), reason));
    }
}
```

## 7. 측정과 개선

### 7.1 언어 품질 지표
- **용어 일관성**: 동일 개념에 대한 용어 통일도
- **코드 가독성**: 비개발자도 메서드명만으로 기능을 이해할 수 있는 정도
- **신규 팀원 온보딩 시간**: 도메인 이해에 소요되는 시간

### 7.2 지속적 개선 방법
- **분기별 용어집 리뷰**: 도메인 전문가와 함께 용어 검토
- **코드 메트릭 모니터링**: 메서드명 길이, 주석 비율 등 추적
- **팀 피드백 수집**: 언어 사용의 어려움과 개선 제안 수렴

---

## 결론

유비쿼터스 언어는 단순한 명명 규칙이 아닌, 도메인 지식을 코드로 정확히 전달하는 핵심 수단입니다. 이를 통해 비즈니스와 기술이 진정으로 정렬되고, 지속 가능한 소프트웨어를 만들 수 있습니다.

**성공의 핵심**:
- 도메인 전문가와의 지속적인 협업
- 팀 전체의 일관된 언어 사용 문화
- 언어의 진화를 수용하는 유연한 접근법

유비쿼터스 언어는 DDD의 핵심 원칙이자, 성공적인 도메인 모델링의 출발점입니다.

> 이 글은 AI Agent('Claude')를 이용해 생성했습니다.
